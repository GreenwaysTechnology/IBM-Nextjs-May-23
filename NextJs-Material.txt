
Next ={User interface + back end}

User interface -React
Back end
  -REST API
  -GraphQL API
  -Along with database -sqli,primisa

Lab setup:
1.vs code
2.node.js latest version
3.docker is optional - database integration....
.................................................................................
				Next js
..................................................................................
What is a Next?
 Next is a flexible React framework that gives you building blocks to create fast web applications.

Web Applications:
.................

What is web app?
  Type of distributed app,deployed at server , accessed over network(internet) vi various network protocals like http,tcp,smtp...
  
  Web apps works based on request and response model.
  Web apps are hosted on server called web server.

Web server receives request , runs a program, that program returns response to the client.

Reponse would be document.
=>HTML
 
other reponses types
XML,JSON,Documents,images,vidoes.........

What is web and why it was created?

  Tim Berners-Lee, a British scientist, invented the World Wide Web (WWW) in 1989, while working at CERN. The web was originally conceived and developed to meet the demand for automated information-sharing between scientists in universities and institutes around the world.

The first Web browser is line mode web browser,launched in 1992.

The first web server is NeXT computer

The first web page , lanuched http://info.cern.ch/hypertext/WWW/TheProject.html


Types of Web application:

1.Static web applications - 1989 to 1995 (Now a days also people are building this type apps)
   Hard coded html pages , prepared html pages  kept at webserver , the webserver will send those html pages to clients(browsers)

2.Dynamic Content generation application(1996 to till date)
  After 1995, many people thought that how we can use web for biz information system
 how to share biz informations via internet.
 Generally biz data is stored in databases , how to embed data base data into html pages

 1.web server need to talk to database
 2.web server need to prepare html pages based on database records
 3.Those information must be transported to web clients

Web server core design to get client request and send html response to the client.

Along with web server, something was introduced called "Programming language runtime"

The first run time was created based on "c" language called "CGI-comman Gate way interface" later instead of c language "PERL" language.

3.Web services-1998 to till date
 Rise of ECommerce, using internet and web how to exchange data between two biz organizations.
 The existing html technology was not suitable to send and recive data because html is just user interface document language.
 We need to data to be exechanged, thats where new data model was created called 'XML'
xml based web apps called web services.

soap protocal was created to transfer XML based documents "SOAP based webservices"

After 2005 soap based web services, started failing due to mobile computing.

New Web services  were designed called "RestFull Web services"

Restfull web services were used to build any type of data formats like json,xml,pdf,html etc...


4.Client side web apps called "Single Page Web Apps"(2007 to till date)

Single page web apps are built using javascript at client side where as server side web services(REST apis) are used.

SPA Tech stack:
HTML 5,CSS 3, Javascript.
Frameworks build based on SPA

1.Angular js
2.react
3.vue js
.....................................................................................
			  React as SPA lib
.....................................................................................

Reactjs was created by facebook , in order to build SPA applications for browsers.

Advantages of SPA:
1.Pages are created  at client side, so server load is completly removed
2.SPA reduces the lot of phsyical pages after deployment.
3.Clear separations of concerns.

Drawbacks of SPA:
.................

Pure client SPAs are problematic when the app is senstive to SEO and time-to concept
This is because the browser will recive a large empty HTML page and has to wait until the javascript is loaded before rendering any thing.

The brith of new Technology called  "SSR" -  Server Side Rendering:
..................................................................................
 I need SEO but at the same time, i want to use SPA as well.

We provides first class api to "render"  an SPA app into HTML strings on the server.
This allows server to send back already rendered HTML, allowing end users to see the content immediately while the javascript is being downloaded.

This process is called "hydration", the app is compiled at server side and sent to the client which will be  interactive.

SSR types:
 =>Partil SSR 
     We have SPA already, but only few pages(index.html) page is pre compiled at server and sent to client , from where client apps(spa) starts working.

Generally React has api called "ReactDOMServer" using this api we have to render html page on node js(express/hapi)
 
 =>Full SSR
     Every thing is compiled at server side , where as client logics like api calls using ajax is done at client side once the app is rendered.

=>Full Stack apps: =>Full SSR(Next.js)
   Using react like apps are built using full stack apps=>Next js

Next js Arch with respect to SSR
.................................

please refer pic
 

SSG/JAMStack: (Static Site Generation)
............

What is Jamstack?
Jamstack is an architectural approach that decouples the web experience layer from data and business logic, improving flexibility, scalability, performance, and maintainability.

Jamstack removes the need for business logic to dictate the web experience.

Just sending HTML pages to the client without preparing htmls pages while requesting.

SSR will prepare html at server side during "request-response  phase/cycle"

Server side rendering can be done "ahead of time"-->SSG.This means we can pre render an entire application into HTML and serve them as static files.
This improves site performance and makes deployment a lot simpiler we no longer need to dynamically render pages on request.
.....................................................................................
			   Next js  -SSR and SSG
.....................................................................................

Next js is full stack web framwork built on the top of react core features  to build modern SSG and SSR apps at very fast...

Next js uses "rust based build system" where as react uses web pack build ....
.....................................................................................
			 Basic building block of Next js(Web apps)
.....................................................................................
1.page
2.Routing
3.Data Fetching
4.Rendering - Client side rendering(traditional ajax) + server side rendering
6.Styling
7.Type script is another language of choice building strongly typed server side apps
8.API Develovement
...................................................................................
			 Next app setup 
....................................................................................

Next app technologies:

1.React
  It is free and opensource front-end javascript lib for building user interfaces

2.Turbopack
   An intcremental bundler optimized for javascript and typescript written in Rust and built into Next js

3.Speedy web compiler
   A Extensible to Rust based platform for the next generation of fast developer tools, and can be used for both compilation and bundling.

4.Vercel platform
   Vercel is the company who created next js, they are providing a platform to deploy applications in cloud, server less env.

.....................................................................................
Installing Next infrastructure:

System Req:
 ->Node js 16.8 or later
 ->OS - it can be windows, mac or Linux are supported

Two types of installation
1.Automatic installation
   Which setps everything automatically for you.

npx create-next-app@latest
Need to install the following packages:
  create-next-app@13.4.2
Ok to proceed? (y) y
âˆš What is your project named? ... my-app
âˆš Would you like to use TypeScript with this project? ... No / Yes
âˆš Would you like to use ESLint with this project? ... No / Yes
âˆš Would you like to use Tailwind CSS with this project? ... No / Yes
âˆš Would you like to use `src/` directory with this project? ... No / Yes
âˆš Use App Router (recommended)? ... No / Yes
âˆš Would you like to customize the default import alias? ... No / Yes
Creating a new Next.js app in E:\session\IBM\2023\May\NextJS\my-app.

Using npm.

Initializing project with template: app-tw


Installing dependencies:
- react
- react-dom
- next
- tailwindcss
- postcss
- autoprefixer

2.Manual Installation
 npm install next@latest react@latest react-dom@lastest


package.json
{
  "name": "my-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "autoprefixer": "10.4.14",
    "next": "13.4.2",
    "postcss": "8.4.23",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "tailwindcss": "3.3.2"
  }
}

scripts:
 dev: runs next dev to start next.js in development mode
 build: runs next build to build the application for production usage
 start: runs next start to start a next apps in production mode.
 lint: runs next lint to set up next built in eslint configuration.


next.config.js

/** @type {import('next').NextConfig} */
const nextConfig = {}

module.exports = nextConfig

 This is going to be used for configuring the next apps.


src/app
  having basic start up files

layout.js
page.js
   landing page is available inside layout.js

public:
  stores static assests such images,fonts,documents
  public dir are accessed inside code using the base URL "/".


How to start dev server?

 npm run dev
....................................................................................
			 Root File/Root Component
.....................................................................................

In react , there is index.html which is built in ready made file, inside that file only we create DOM tree and we insert

index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root">
      
    </div>
  </body>
</html>

here div element is root container element.inside we create DOM tree and insert which is called SPA
  HTML elements are created at client only.

Where as SSR , index.html and other html files are created server side.

How to create index.html in Next app?

 Next provides a root Component called "RootLayout"
// import './globals.css'
import { Inter } from 'next/font/google'

const inter = Inter({ subsets: ['latin'] })

export const metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
}

// export default function RootLayout({ children }) {
//   return (
//     <html lang="en">
//       <body className={inter.className}>{children}</body>
//     </html>
//   )
// }
export default function RootLayout(props) {
  return <html lang="en">
    <body>
      <h1>Welcome to Next app</h1>
    </body>
  </html>
}

Here the component name can be any thing "RootLayout" or "MyLayout" "AppLayout"
but the next is going to identify the root component based on file names


Arrow functions:
const RootLayout = ({ children }) => {
  return <html lang="en">
    <body className={inter.className}>{children}</body>
  </html>
}
export default RootLayout;
....................................................................................
			 React Foundation for Next Js
....................................................................................

React is based on Component driven Architecture.

What is Component?
 Component is object.
 Since Component is object we can reuse.
 Component represents a User interface.

There two types of components

1.client side components
  Components are used in the single page webs 
2.server side components
  Components are used in the server side.

Server and clients components allow developers to build apps that span the server and client ,coimbining the rich interactivity of client side apps with the improved performance of traditional server rendering.


Thinking in Server Components:
..............................

React was created for building SPAs.
but how react changed the way we think about building UI,React server components  introduce new mental model for building hybrid apps that leverage the server and client.

=>Instead of React rendering your whole app client-side(such as in the case of Single Page applications).
 React now gives you the flexibility to choose where to render your components based on "their purpose"

Why server Components?
......................

1.Performance:
1.1. Server components allow developers to better leverage server infrastructure. for      eg large dependencies that previously would impact the javascript bundle size on      the client can instead remain entirely on the server.

1.2.They make write a react apps feels similar like jsp and servers,aspx,php or ruby on   rails but the power and flexibility of react and the components model for   templating UI

1.3.When server components the inital page load is faster,client side javascript bundle is reduced.

1.4.We can able caching 

1.5.if you want add client side interactivity we can use "client components"

2.Progressive:
...............
1.When a route(index page) is loaded with Next.js, the inital HTML is rendered on the server.
2.The HTML is then progressively enchanced in the browser, allowing the client to take over the application and add interactivity.

.....................................................................................
				Client Components
.....................................................................................
Client components enable you to add interactivity in the client side to your application.

"In Next.js" they are pre-rendered on the server and hydrated on the client.

You are creating a component , how to say this component is client side and server side..

export default function Greeting(props){
	
	return <>
		<h1>Hello Next</h1>
             <>

}

How to define that the above code, must be executed in the server or client

'use client'  // "use Client" directive

export default function Greeting(props){
	
	return <>
		<h1>Hello Next</h1>
             <>

}
.....................................................................................
  	When to use server side component and when to use client side component
.....................................................................................

what do you need?                         Server    client 
					component  component

1.Fetch data                               yes       no

2.Access back resources(directly)          yes       no

3.Keep security related info(api keys)     yes       no


4.large bundle dependencies/reduce client
  js                                       yes       no

5.Add interactivity and event listeners    no        yes

6.Use state and life cycles hooks          no        yes

7.Use browser only api(storage)            no        yes

8.Custom hooks that depend on state,effects
  browser apis                             no        yes

9.if you write "class components"          no        yes


Patterns:
........
1.Moving clients components to the leaves(tree):
..............................................

if you want to improve perfomance and also add strong security we recommend moving client components to the leaves of your component tree where ever possible.

if you have layout having static data  like logo,links and an interactive search bar that uses state.

Instead of making the whole layout a client component, move the interactive logic to client component eg <SearchBar/> and keep your layout as Server component.

2.Composing Client and Server components:
..........................................

Server and clients components can be coimbed in the same component tree.

Process behind server and client components:
............................................

=>On the server, React renders all Server components before sending the result to the client
   =>This includes server components nested inside client components
   =>What if the client components are encounted in this stage, it will be skipped.

=>On the client, React renders Client Components and slots in the rendered result of server Compoents
   =>if any server components are nested inside a client,their rendered content will placed correctly the client component during client compoenent rendering

In Next js, during the inital page load, both the rendered result of server components from the above step and client components are pre-rendered on the server as plain html to produce a faster initall page load.
.....................................................................................

"Recommended Pattern: Passing Server components to client components as prop"
.....................................................................................
			  Pages & Routing
.....................................................................................

The core of next apps are routing.
The skeleton of every app is routing.

Pages:
......
  A page is UI that is unique to a route.
  You can define pages by exporting a component from page.js file to make the route   publicly accessible
  
Create first Page by adding a page.js file inside app directory. 

By default routing is enabled,automatically, unlike react spas you dont need to specify the routing.

Note: in next js you dont need to configure any routers, routers are mapped against files

http://localhost:3000/  =>Root URL(route) => page.js

  By default root path is mapped against page.js

src/app/page.js

export default function HomePage() {
    return <h1>
        Hello,Welcome to Next js
    </h1>
}

app/page.js  ----> /

How to define new route and render accordingly?

app/about/page.js   => /about
   
export default function About(){
    return <h1>About us</h1>
}

app/dashboard/page.js  ====> /dashboard


export default function DashBoard() {
    return <h1>Dashboard</h1>
}

app/dashboard/settings/page.js     ===> http://localhost:3000/dashboard/settings
....................................................................................
			Routing core concepts
....................................................................................

Inside the app directory, folders are used to define routes.

Each folder represents a "route segment" that maps to a "URL" segment. To create nested route, you can nest folders inside each other.

	localhost:3000 /     dashboard /settings
		       |        |          |
		 Root segment  Segment     leaf Segment

How to create segments(eiether root/segement/leaf)?
  A special file called page.js to make route segments publicly accessible.

if you different name other than page.js , it will not be avaible for public access.

 app/dashboard/config/myconfig.js

http://localhost:3000/dashboard/config/myconfig
.....................................................................................
			   Creating UI
.....................................................................................

Special file conventions are used to create UI for each route segment.

File convention
pages -  page.js
layouts - layout.js
routes   - route.js - server side end points
templates  - template.js
loading   ----loading.js
errors    -----error.js,global-error.js,not-found.js 
..............................................................................
Roles of Folders and files:
..........................

1.folder are used to define routes. A route is a single path of nested folders, following the hierarchy from the the root folder down to a final leaf folder that includes a page.js file

2.Files are used to create UI that is shown the route segment
....................................................................................

page.js :  create the unique UI of a route and make the path publicly accessible
  -route.js : create server side apis/endpoints for a route

layout.js:
  Create shared UI for a segement and its children.
  A layout wraps a page or child segement.
 -template.js
     Similar to layout.js execpt  a new component instance is mounted on navigation.
loading.js
   To show progress bar while loading ui, it uses reac Suspense boundary.
 
error.js
  to handle ui errors,internally it uses error boundary
  ->global-errors.js 
      catching errors in the layout layer level
  ->not-found.js
        this is shown when if there is no url segment matches...
....................................................................................
			   Component hierachy
....................................................................................

layout.js
  Every next app must have one layout.js which define root layout.

template.js
   Templates are similar to layouts that wrapy each child layout or page.

error.js 
   React Error boundary - layout level errors

ErrorBoundary:
Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed. Error boundaries catch errors during rendering.

loading.js
   Which loads component in async manner
   Components render sync manner.
Lazy loading:
  load components in delayed manner
React lazy loading is done via Suspense Component

not-found.js :React Error Boundary
    This is component used to handle errors during component load/page


page.js or nestlayout layout.js
   Actual UI is displayed

Component Structure/Hierarchy:
..............................

<Layout>
   <Template>
	<ErrorBoundary fallback={<Error/>}>
	   <Suspense fallback={<Loading/>}>
		<ErrorBoundary fallback={<NotFound/>}
		    <Page/>	
		<ErrorBoundary>
           <Suspense>	
        </ErrorBoundary>
   </Template>	
</Layout>
....................................................................................
			Nested Route component Hierachy
....................................................................................
app/
 page.js
 layout.js
 not-found.js
 template.js
 loading.js
 error.js
 
dashboard
  -layout.js
  -error.js
  -loading.js
  
<Layout>
    <ErrorBoundary fallback={<Error/>}>
	  <Suspense fallback={<Loading/>}>
		<ErrorBoundary fallback={<NotFound/>}
		    <Page/>	
		<ErrorBoundary>
           <Suspense>	
        </ErrorBoundary>
   
</Layout>

app/
 page.js
 layout.js
 not-found.js
 template.js
 loading.js
 error.js
 
dashboard
  -layout.js
  -error.js
  -loading.js
settings
  -layout.js
  -error.js
  -loading.js
  -page.js


dashboard/settings
  
<Layout>
    <ErrorBoundary fallback={<Error/>}>
	  <Suspense fallback={<Loading/>}>
	     <Layout> <!-- settings---!>
		<ErrorBoundary fallback={<Error/>}>
		    <Suspense fallback={<Loading/>}>
			<Page/>
		    </Suspense>
		<ErrorBoundary>
	     <Layout/>
           <Suspense>	
        </ErrorBoundary>
   
</Layout>

...................................................................................
   			 Linking and Navigation
...................................................................................

The Next.js router uses  "Server centric routing with client side navigation

In old next versions there is pages dir which uses client side routing, the App router uses "server centric routing" to algin server components and data fetching on the server. with server centric routing, the client does not have to  download to route map and the request for compoentents can be use to look up routes.
			
Client side Navigation or client Routing:
..........................................
 The pages are transfered from one page to another page using hyper links or there are js apis like router.push method.
 Client navigation done by the browser apis
 Server side navigation done by the server
			
There are two types of components for naviation.

1.Link compoenent
2.useRouter Hook

Link Components
Props
 ->href -required
 ->replace 
 -prefetch
 -shallow
 -local

Link Eg:

src/app/page.js
import Link from 'next/link'
import styles from './page.module.css'

export default function Home() {
  return (
    <main className={styles.main}>
      <div className={styles.description}>
        <nav>
          <Link href="/dashboard">Dashboard</Link>
          <Link href="/products">Products</Link>
        </nav>
      </div>
    </main>
  )
}

src/app/dashboard/page.js
export default function DashboardPage() {

    return <div>
        <h1>Dashboard</h1>
    </div>
}
src/app/products/page.js
export default function ProductsPage() {
    return <div>
        <h1>Products</h1>
    </div>
}
.................................................................................
			 Dynamic Routes
.................................................................................

Url Pattern 
  /products/1
  /users/2

When you dont know the exact segment names ahead of time and want to create routes from dynamic data, you can use Dynamic segments that are filled in the run time or prerendered at build time.

Syntax:
How to create dynamic segment?
  A segment is created by wrapping a folder's name in square brackets

 [folderName] for eg [id] [slug] [name] [city]

slug is convetional name used in next js to denote dynamic path.

slug:
 A slug is the part of a URL that identifies a particular page on a website in an easy-to-read form. In other words, it's the part of the URL that explains the page's content. For this article, for example, the URL is https://yoast.com/slug, and the slug simply is 'slug'

src/app/blog/[slug]
 |

src,app,blog,[slug] all are folders only

src/app/blog/[slug]
  -page.js
  -layout.js
  -template.js
 etc...   

src/app/blog/[slug]
  page.js

export default function Blog(props) {
    return <div>
        <h1>Blog</h1>
    </div>
}
Testing:
 http://localhost:3000/blog/1
 http://localhost:3000/blog/2
 http://localhost:3000/blog/3
 http://localhost:3000/blog/4

Reading Dynamic segemnts can be read inside Page,layout,route,geneateMetaData functions.
Dynamic Segments are available inside page via props.params 

props.params will return
  {folderName:1}

read: props.params.slug 
.....................................................................................
			 Catch-all Segments
....................................................................................
Dynamic segements can be extended to catch-all subsequent segements by adding an ellipsis inside the brackets [...FolderName]

eg:
 app/shop/[...slug]/page.js will match the url pattern like below
    /shop/cloths 
    /shop/cloths/tops
    /shops/cloths/tops/t-shirts 
    /shop/food
    /shop/food/veg

Route                                    url                     params
app/shop/[...slug]/page.js		/shop/a                 { slug: ['a'] }

app/shop/[...slug]/page.js		/shop/a/b               { slug: ['a','b'] }


eg:
src/app/shop/[...slug]/page.js

export default function Shop(props) {
    const nestedParams = props.params.slug
    return <div>
        <h1>Shop</h1>
        {nestedParams}
    </div>
}
Testing:
http://localhost:3000/shop/cloths/tops/tshirts
....................................................................................
			Optional Catch-all Segments
...................................................................................
catch all segements can be made optional by including the parameter in double square brackets
    [[...folderName]]
eg:
 /app/movie/[[...slug]]/page.js will match
   
    /movie
    /movie/eng
    /shop/eng/sciencefiction


Route                                    url                     params
app/movie/[[...slug]]/page.js		/movie                   {  }

app/shop/[[...slug]]/page.js		/movie/eng              { slug: ['eng'] }
....................................................................................
			   React Components
.....................................................................................

React components are just represent UI.

Next Components
  Layouts and pages

Page represents UI.

export default function ShopPage(){ 
        return <Product/>
}
....................................................................................
		 Server components and clients components
....................................................................................

Server components:
 =>Server components are rendered in the server side

Using useState hook inside component:

src/app/counter/page.js
import Increment from "./increment";

export default function CounterPage(props){
    return <div>
        <h1>Counter Page</h1>
        <Increment/>
    </div>
}

src/app/counter/increment.js
import { useState } from "react"

export default function Increment() {
    const [count, setCount] = useState(10)
    return <>
        <h2>Increment : {count}</h2>
    </>
}

http://localhost:3000/counter

You will encounter error like below

Failed to compile

Next.js is up to date
./src\app\counter\increment.js
ReactServerComponentsError:

You're importing a component that needs useState. It only works in a Client Component but none of its parents are marked with "use client", so they're Server Components by default.

   ,-[E:\session\IBM\2023\May\NextJS\client-servercomponents\src\app\counter\increment.js:1:1]
 1 | import { useState } from "react"
   :          ^^^^^^^^
 2 | 
 3 | export default function Increment() {
 3 |     const [count, setCount] = useState(10)
   `----

Maybe one of these should be marked as a client entry with "use client":
./src\app\counter\increment.js
./src\app\counter\page.js
 
The above is called "Client Code" , so this code cant be compiled in server

By default every component is "Server is component".
Server components 
  page,layout,templates,loading....

Client components
  There is directive 'use client'; 


src/app/counter/counter.js | counter.jsx

'use client';

import { useState } from "react"

export default function Increment() {
    const [count, setCount] = useState(10)
    return <>
        <h2>Increment : {count}</h2>
        <button onClick={() => setCount(count + 1)}>+</button>
    </>
}

//custom Hook -- useState,browser api,useEffect,listeners

Client side code will not trigger page reloads for every mutation....
....................................................................................

Even simple listerners also considered Client Side code

'use client';


export default function Alert() {
    return <>
        <button onClick={() => alert('Hello,Next j')}>Alert</button>
    </>
}

Pointers:
..........
=>Compoenents in the server moudule graph(component tree) are guaranteed to be ony rendered on the server.
=>Components in the client module graph(compoent tree) are primarily rendered on the client but with Next.js they can also be re-rendered on the server and hydrated on the client. precompile as plain/raw html and execute as dom tree in the client.

=>'use Client' directive must be top of a file before any imports
....................................................................................
			Client Component uses another Client Components


src/app/review/reviews.js

import Like from "./like"
import Dislike from "./dislike"

//client component
export default function Reviews(){
    return <>
        <Like/>
        <Dislike/>
    </>
}

src/app/review/like.js

 'use client';

import { useState } from "react"

//client component
export default function Like(){
    const [count, setCount] = useState(10)
    return<>
        <h1>Like {count}</h1>
    </>
}

src/app/review/dislike.js
 'use client';

import { useState } from "react"

//client component
export default function Dislike() {
    const [count, setCount] = useState(10)
    return <>
        <h1>Dislike {count} </h1>
    </>
}

if you use clients inside another clients, you can use "use client" directive only top level /parent component only.

eg:
 'use client';

import Like from "./like"
import Dislike from "./dislike"

//client component
export default function Reviews(){
    return <>
        <Like/>
        <Dislike/>
    </>
}
//  'use client';

import { useState } from "react"

//client component
export default function Dislike() {
    const [count, setCount] = useState(10)
    return <>
        <h1>Dislike {count} </h1>
    </>
}
//  'use client';

import { useState } from "react"

//client component
export default function Like(){
    const [count, setCount] = useState(10)
    return<>
        <h1>Like {count}</h1>
    </>
}
.....................................................................................
Patterns:
1.Server components has client Compoents - discussed already
2.Clients Components has another client compoents.-discussed already
3.Client Component has server Component			 
...................................................................................
			Client Component has server Component


src/app/client/page.js
import ClientComponent from "./client";

export default function ClientPage(){
    return <>
        <h1>Server Page</h1>
        <ClientComponent/>
    </>
}

src/app/client/client.jsx

'use client';

import ExampleServerComponent from "./server-component";

export default function ClientComponent() {

    return <>
        <button onClick={() => {
            alert('Client Compoent')
        }}>Client</button>
        <ExampleServerComponent/>
    </>
}
src/app/client/server-component.js

export default function ExampleServerComponent() {
    return <>
         <h1>ExampleServerComponent</h1>
    </>
}

Note : this pattern is not recommened. Why

if you render any server component inside client component, implicitly server compoent becomes client component. so that we will loose the purpose of server components.
..................................................................................

What if i want to render server components inside client compoents without lossing server compilation?
   Pass Server Component  to Client component as "props"
   
src/app/client/page.js

import ClientComponent from "./client";

import ExampleServerComponent from "./server-component";

export default function ClientPage() {
    return <>
        <h1>Server Page</h1>
        {/* <ClientComponent/> */}

        {/* Server Component passed as prop */}
        <ClientComponent>
            {/* Server Component passed as prop */}
            <ExampleServerComponent />
        </ClientComponent>
    </>
}

src/app/client/server-component.js

export default function ExampleServerComponent() {
    return <>
         <h1>ExampleServerComponent</h1>
    </>
}

src/app/client/client.js
'use client';

//new pattern: server components are rendered inside client component as prop

export default function ClientComponent(props) {
    console.log(props)
    return <>
        <button onClick={() => {
            alert('Client Compoent')
        }}>Client</button>
        {/* <ExampleServerComponent /> */}
        {props.children}
    </>
}
....................................................................................
			 Dynamic Routing with Data and Links
....................................................................................

Data i am going to use mock data.

src/app/posts/page.js
import Link from 'next/link';
import posts from './post-mock'

export default function PostList() {
    return (
        <ul>
            {posts.map((post) => (
                <li key={post.id}>
                    <Link href={`/blog/${post.id}`}>{post.title}</Link>
                </li>
            ))}
        </ul>
    );
}


src/app/blog/[slug]/page.js
export default function BlogDetails(props){
    return <div>
        <h1>Blog Details {props.params.slug}</h1>
    </div>
}
...................................................................................
		 Programmetic navigation using "useRouter" Hook
...................................................................................

The useRouter Hook allows you to programmetically change routes inside client components.

eg:
src/app/photos/page.js

import PhotoDetails from "./photo-detail";

export default function PhotoPage(){

    return <>
        <h1>Photo Page App</h1>
        <PhotoDetails/>
    </>
}
src/app/photos/photo-detail.jsx
'use client';

import { useRouter } from "next/navigation";

export default function PhotoDetails() {
    const router = useRouter();
    return <>
        <h1>Photo Details</h1>
        <button onClick={() => {
            router.push('/posts')
        }}>Post</button>
    </>
}
.....................................................................................
			Nested Layouts - Deep Dive
.....................................................................................

Use case 1: render the page inside root layout only

src/app/layout.js
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )

root layout
src/app/layout.js
// import './globals.css'
import { Inter } from 'next/font/google'

const inter = Inter({ subsets: ['latin'] })

export const metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
}

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}

nested layout

src/app/blog/layout.js

export default function BlogLayout({ children }) {
    return <div id="bloglayout">
        {children}
    </div>
}

src/app/blog/settings/layout.js

export default function BlogLayout({ children }) {
    return <div id="bloglayout">
        {children}
    </div>
}
....................................................................................
			 Routes Groups /Hidden Directories
....................................................................................
Directory structures 

src/app/blog/page.js  => /blog

src/app/blog/[slug]/page.js  => blog/1
......................................................................

src/app/blog/(folderName)/subfolders/page.js : Hidden Directories

What is Route group?
 The hierachy of the app folder maps directly to URL paths.

 /app/blog/page.js =>/blog

How ever, it is possible to break out of this pattern by creating a route group.

Route Groups can be used to 

-Organize routes without affecting the URL structure.
-Opting-in specific route segement into a layout
-Create multiple route layouts by spilting your apps

Eg:
src/app/(auth)
  -login
    -page.js
  -signup
    -page.js

/signup/page.js
export default function SignUp(){
    return <h1>
        SignUp Page
    </h1>
}
/login/page.js
export default function Login(){
    return <h1>
        Login Page
    </h1>
}

URL Pattern:
http://localhost:3000/signup
http://localhost:3000/login
You cant use like below , because it is hidden
http://localhost:3000/auth/signup
.....................................................................................
			Route Groups and shared layout
....................................................................................
(auth)
  layout.js
This layout can be a shared layout....

src/app/(auth)/layout.js

export default function AuthLayout({ children }) {
    return <div>
        <h1>Auth Header</h1>
        {children}
    </div>
}

http://localhost:3000/logout

Auth Header
Logout
...................................................................................
		sharing layouts under hidden directories and nested layout

src/app/(auth)/login/layout.js

export default function LoginLayout({ children }) {
    return <div>
        <h1>Login Header</h1>
        {children}
    </div>
}
.....................................................................................
			 Parallel Routes
.....................................................................................
What is Parallel Routes?

 Parallel routing allows you to simultaneously or conditionaly render one or more pages in the same layout.

Parallel routing is used to implement complex routing pattrns.

Use case 1: Render multiple pages into single layout
.....................................................

Steps:

1.create folder called game
src/app/game
2.create page.js and layout.js
export default function GameLayout(props) {
    return <div id="gamelayout">
         {props.children}
    </div>
}
export default function GamePage(props) {
    return <div>
        <h1>Game Page</h1>
    </div>
}
3.Create two different pages and render within "GameLayout"

export default function GameLayout(props) {
    return <div id="gamelayout">
         {props.children}
    </div>
}

in order to implement parallel routing, we need to create folder

@folderName
  |
  page.js

src/app/game/@team/page.js
export default function TeamPage(props) {
    return <h2>
        Team Page
    </h2>
}
Now if you test 
http://localhost:3000/game/team
The output would be page not found, the reason is you cant access team page publicly, 
Team page must be injected into Team's layout as prop.


src/app/game/@anaylitics/page.js
export default function AnalyticsPage(props) {
    return <h2>
        Analytics  Page
    </h2>
}

export default function GameLayout(props) {
    return <div id="gamelayout">
        {/* Game Page  */}
        {props.children}
        <hr />
        {/* Team Page */}
        {props.team}
        {/* Analytics Page */}
        {props.analytics}
    </div>
}
.....................................................................................
				Conditional Rendering-Parallel Routing
.....................................................................................

As of now, we have seen how to render multiple pages into a layout.
Now we are going to discuss how to render page or pages into a layout based on condition.
Slot  means portion of UI.
We render a slot based on certain conditions, such as checkbox values,authentication states.

Syntax:
@AdminPanel
@UserPanel
export default function MyLayout(props) {
  const isAdmin = getUser()
   
  return isAdmin ? props.AdminPanel : props.UserPanel

}

eg:

src/app/panel/page.js
export default function PanelPage(props) {
    return <div>
          <h1>Panel Page</h1>
    </div>
}

src/app/panel/@AdminPanel/page.js
export default function AdminPanelPage(props) {
    return <div>
          <h1>AdminPanelPage</h1>
    </div>
}


src/app/panel/@UserPanel/page.js
export default function UserPanelPage(props) {
    return <div>
          <h1>UserPanelPage</h1>
    </div>
}

src/app/panel/layout.js

export default function PanelLayout(props) {
    const isAdmin = false 
    return <div>
         {props.children}
         {isAdmin ? props.AdminPanel : props.UserPanel}
    </div>
}
src/app/panel/page.js
export default function PanelPage(props) {
    return <div>
          <h1>Panel Page</h1>
    </div>
}

Points:
 Parallel routes are created using named slots.
 Slots are defined with the @folderName convention
 Slots are passed as prop to the layout

..................................................................................
			   Loading UI 
..................................................................................

The special file loading.js helps to create meaningful loading UI with React suspense.
With this convention, you can show an instant loading state from the server while the content of a route segment loads, the new content is automatically swapped in once rendering is completed.

steps:
src/app/dashboard/layout.js
export default function DashBoardLayout(props) {
    return <>
      {props.children}
    </>
}
src/app/dashboard/loading.js
export default function Loading() {
    // You can add any UI inside Loading, including a Skeleton.
    return <h2>ðŸŒ€ Loading...</h2>;
}
src/app/dashboard/components/greeter.jsx

export default function Greeter(props){
   return <>
     <h1>Hello</h1>
   </>
}

src/app/dashboard/page.js
import React  from 'react';

const Welcome = React.lazy(() => {
    return new Promise((resolve, reject) => {
        //lazy loading component: here greeter to be loaded async , meaning that this component to be available only after 5000 ms,
        //during 5000 ms  , we need to show some Spinner,thats where loading.js code 
        //to be used
        setTimeout(resolve, 8000, import('./components/greeter'))
    })
});

export default function DashboardPage(props) {
    return <>
      <h1>Dashboard Page</h1>
      <Welcome/>
    </>
}

Component Structure:

 <Layout>
   <Supsense fallback={<Loading/>}
	<Page/>
   </Suspense>
 </Layout>
....................................................................................
	Putting loading status within page : overriding existing loading.js code

Can we add Loader via Suspense Manually,
 Yes, we can add, alway local Suspense takes priority.

export default function DashboardPage(props) {
    return <>
        <h1>Dashboard Page</h1>
        {/* <Welcome /> */}

        <Suspense fallback={<h1>Loading.....</h1>}>
            <Welcome />
        </Suspense>
    </>
}
Recommendation:
 Use the loading.js convention always for route segments as Next.js optimizes this functionality.
...................................................................................
			Streaming
...................................................................................
What is Streaming?
 Before understanding what is streaming, we need to understand how SSR works and its limiatation
 Streaming is going to enchance the SSR limiations.

Steps Involved In SSR:
.....................

1.First , all data for a given page is fetched on the server.

2.The server then renders the HTML page 

3.Once the HTML is ready, the server will send HTML,CSS,javascript for the page are sent to the client.

4.NonInteractive user interface is shown using the generated HTML and CSS In browser

5.Finally React, Hydrates,the user interface to make it interactive


TTFB: Time to First Byte:
........................
Time to First Byte (TTFB) refers to the time between the browser requesting a page and when it receives the first byte of information from the server. This time includes DNS lookup and establishing the connection using a TCP handshake and SSL handshake if the request is made over HTTPS


FCP :First Contentfull Paint
The First Contentful Paint (FCP) metric measures the time from when the page starts loading to when any part of the page's content is rendered on the screen

TTI
Time to Interactive (TTI) is a non-standardized web performance 'progress' metric defined as the point in time when the last Long Task finished and was followed by 5 seconds of network and main thread inactivity.21-Feb-2023

These steps are sequentinal and blocking, meaning that the server only render HTML for a page once all the data has been fetched. 
And on the client side React can only hydrate the UI once the code for all components in the page has been downloaded..

this is traditional process, which degrades the app loading performance
.....................................................................................
		  How to improve loading performance
....................................................................................

SSR with React and Next.js helps improve the perceived loading performance by showing a non interactive page to the user as soon as possible.

Only HTML can be sent once the data fetching is over.


Streaming allows you to break down the page's HTML into smaller chunks and progressively send those chunks from the server to the client.

This enables part of the page to be displayed sooner, without waiting for all the data to load before any UI can be rendered.

How to break down into chunks?

  React mental model is component driven, each component we can treat as chunk.

eg:
  if a component have priority or that dont rely on data can be sent first (eg layouts),so the react can hydration eariler....
 if components has less priority, or depends data to be sent later...

How to implement streaming?
 You have to split code into segments

1.static code which does not depend on data
2.dynamic code which depends on data.

if you wrap any component with "Suspense Boundary" which is async, can be rendered later.

if the component relays on data fetching, delays with timers, delays with network connections......

Streaming Component:
....................

export default function Product(props) { 
   <section>
    <nav><a href="product.html"><a></nav>
    <Suspense fallback={<h1>loading....}>
	 <ProductDetails/>
     <Suspense>
   <section>
	
}

Through suspense we can enable streaming....

1.Streaming server rendering: Progressively rendering html from the server to the client

2.Selective Hydration 
    React prioritizes what components to make interactive first based on user interaction.
.....................................................................................
			 Error Handling
....................................................................................

The error.js file convention allows you to handle runtime errors in nested routes.

By default Nextjs , wraps your components /pages/layouts within ErrorBoundary only...

if you want to customize the error messages, we can add error.js within the route of app or within nested route.

Create ERROR ui tailored to secific segements using the file system hierarchy to adjust granualrity.

...................................................................................
				Route Error Handler
....................................................................................

app
 |
 page.js
 layout.js
 dashboard
    |
    page.js
    layout.js
    error.js

error.js
 It automatically creates ReactBoundary that wraps a nested child segment or page compoent
  <Layout>
  
    <ErrorBoundary fallback={<Error/>}
	<Layout>
		<Page/>
        </Layout>
    </ErrorBoundary>
  </Layout>

 error components are "client components"

error.js

'use client'; //Error Component must be client component

export default function Error(props) {
    return <div>
        <h2>Something went Wrong!</h2>
    </div>
}

How to access the error information within error Component?
 The error component has prop


'use client'; //Error Component must be client component

export default function Error(props) {
    console.log(props)
    return <div>
        <h2>Error Page</h2>
        <h3>{props.error.message}</h3>
    </div>
}

Recovery from the errors:

How to recover the errors due to some to network failure...


'use client'; //Error Component must be client component

export default function Error(props) {
    console.log(props)
    return <div>
        <h2>Error Page</h2>
        <h3>{props.error.message}</h3>
        <button onClick={() => {
            props.reset()
        }}>Reset</button>
    </div>
}
.....................................................................................
			How to add Error handler at root
.....................................................................................

		 Errors bubble up
..................................................................................
Errors bubble up to the nearest parent error boundary. This means an error.js file will handle errors for all its nested child segments. More or less granular error UI can be achieved by placing error.js files at different levels in the nested folders of a route.

src/app/error.js


'use client'; //Error Component must be client component

export default function Error(props) {
    console.log(props)
    return <div>
        <h2>Error Page</h2>
        <h3>{props.error.message}</h3>
        <button onClick={() => {
            props.reset()
        }}>Reset</button>
    </div>
}
....................................................................................
			How to handle layout errors
....................................................................................

error.js boundaries dont catch errors thrown in layout.js or template.js components of the same segement.

To handle errors within  a specific layout or template , place an error.js file in the parents layout segment.

src/app/error.js

src/app/dashboard
      -page.js
      -layout.js
      -error.js

here dashboard layout errors are not handled by dashboard's error handler,rather its parent error.js file only..

To handle root layout errors, Next provides another file called "global-error.js" file must be used
....................................................................................
			  Data Fetching and API development
....................................................................................

Data Fetching:
..............

Data fetching from the server components or clients are possible.

In server components we can use "fetch" api directly.
fetch is promise powered so , you can use fetch with async await....


Eg: Data fetching in server components:
.......................................

import { Suspense } from "react"

//function to get data
async function getTodos() {
    const url = `https://jsonplaceholder.typicode.com/todos`
    const res = await fetch(url)
    if (!res.ok) {
        throw new Error('data is not available')
    }
    return res.json()
}
function Loading() {
    // You can add any UI inside Loading, including a Skeleton.
    return <h2>ðŸŒ€ Loading...</h2>;
}
export default async function TodosPage() {
    const todos = await getTodos()
    return <div>
        <h1>Todos Page</h1>
        {/* enables streaming */}
        <Suspense fallback={<Loading/>}>
            <ul>
                {todos.map(todo => {
                    return <li>{todo.title}</li>
                })}
            </ul>
        </Suspense>
    </div>
}
.....................................................................................
			 Data fetching in Client Comonents
....................................................................................
Pattern : 1 Using fetch api itself...
'use client';

async function getUsers() {
    const url = `https://jsonplaceholder.typicode.com/users`
    const res = await fetch(url)
    if (!res.ok) {
        throw new Error('data is not available')
    }
    return res.json()
}
export default  async function User(){
    const users = await getUsers()
    console.log(users)
    return <div>
        <h1>User</h1>
        <div>
            {users.map(user=>{
                return <h2>{user.username}</h2>
            })}
        </div>
    </div>
}

Pattern 2  Using 'use' hook:
............................
use is designed to provide much the programming model as "async/await" while still working inside regular(non-async) function components and other hooks.
Similar to async functions in javascript, the runtime for use maintains an internal state machine to suspend and resume; but from the perspective of the component author, it looks and feels like sequenicail function.

As of now use hook is still experimental. not yet stablized/released.

SyntaxL
function getData() {
    return Promise.resolve('Hello Promise')
}

export default function PostPage() {
    const result = use(getData())
    return <div>
        <h1>Post Page</h1>
    </div>
}

Pattern 3:Using swr feature

npm install swr

'use client';

// function getData() {
//     return Promise.resolve('Hello Promise')
// }

// export default function PostPage() {
//     const result = use(getData())
//     return <div>
//         <h1>Post Page</h1>
//     </div>
// }

import useSWR from 'swr'

function fetcher(...args) {
    return fetch(...args).then(res => res.json())
}

export default function PostPage() {
    const url = 'https://jsonplaceholder.typicode.com/posts'
    const { data, error, isLoading } = useSWR(url, fetcher)
    if (error) {
        return <div><h1>Failed to return</h1></div>
    }
    if (isLoading) return <div>Loading....</div>
    return <div>
        {
            data.map(post => {
                return <h4>
                    {post.title}
                </h4>
            })
        }
    </div>
}
.....................................................................................
			Caching  in Data fetching
.....................................................................................
In next js Caching is enabled by default.

Pre-Request caching: 
 fetch
By default , all fetch requests are cached and deduplicated automatically.
This means that if you make the request twice , the second request will resue the result from the first request.

How to revalidate the cache?
 if want to revalidate the cache every request, you can use 

 fetch('url',{next:{revalidate:0}}
 or 
 fetch('url',{cache:'no-store'});
.....................................................................................
			 API development
.....................................................................................

Next provides a layer called "api" layer

api layer is used to write our own rest api or graphql api.

As of now api communication (data fetching) logic of third party , we have done inside either server components or client components.

There are two roles of api layer:

1.integrating third party api 
2.writing our own apis
...................................................................................
				Route Handler -REST api 
...................................................................................

Route  handlers are used to create REST api in next js.
As part of the we can have 
-User interface
  app/
   page.js     /
   layout.js
   api
    |
    route.js  /api

page.js
  =>contains react component which represents User interface

route.js
  => contains rest end points

Resources:
  Resource is nothing but domain domain models

eg:
Cart 
Product
Customer
Payment

How to create apis based on resources?

 src/app/api/
     product
       route.js
     customer
	route.js



route.js
  Inside route.js we write route handlers.

export async function HTTPVerb(request){}

eg:
export async function GET(request){}

Supported HTTP Verb:
 GET,POST,PUT,PATCH,DELETE,HEAD,OPTIONS
if un supported method is called, Next js will return a 405 method not allowed response.

Object supported:
1.NextRequest  for handling incoming request
2.NextResponse for handling responses

eg:
src/app/api/route.js
import { NextResponse } from "next/server";

//rest api
export  async function GET(request) {
    //send response
    return NextResponse.json({ message: 'welcome to api' })
}

Resources based mapping:

src/app/api/customers/route.js

CURD api mapping:
import { NextResponse } from "next/server";

//rest api
//GET 
export  async function GET(request) {
    //send response
    return NextResponse.json({ message: 'CUSTOMERS GET' })
}
//POST 
export  async function POST(request) {
    //send response
    return NextResponse.json({ message: 'CUSTOMERS POST' })
}
//PUT
export  async function PUT(request) {
    //send response
    return NextResponse.json({ message: 'CUSTOMERS PUT' })
}
//DELETE REQUEST
export  async function DELETE(request) {
    //send response
    return NextResponse.json({ message: 'CUSTOMERS DELETE' })
}
....................................................................................
SUB resources:dynamic api route
................................

src/app/api/customers/[id]/route.js
import { NextResponse } from "next/server";
//GET 
export  async function GET(request) {
    //send response
    return NextResponse.json({ message: 'CUSTOMERS GET BY ID' })
}
...................................................................................
			Route Handler talks to third party apis

Next js api route can talk to other apis which might be microservices or plain rest api or graphql api...

eg:
src/app/api/albums/route.js
import { NextResponse } from "next/server";

//rest api
export async function GET(request) {
    //use fetch api to talk to rest end points
    const url = 'https://jsonplaceholder.typicode.com/albums'
    const res = await fetch(url)
    const albums = await res.json();
        //send response
    return NextResponse.json(albums)
}
.....................................................................................
			 Getting data From api and bind user interface

src/app/albums/page.js
import { Suspense } from "react"

async function getAlbums() {
    const url = `http://localhost:3000/api/albums`

    const res = await fetch(url)
    if (!res.ok) {
        throw new Error('data is not available')
    }
    return res.json()
}
function Loading() {
    // You can add any UI inside Loading, including a Skeleton.
    return <h2>ðŸŒ€ Loading...</h2>;
}
export default async function AlbumsPage() {

    const albums = await getAlbums()
    return <div>
        <h1>Albums Page</h1>
        {/* enables streaming */}
        <Suspense fallback={<Loading/>}>
            <ul>
                {albums.map(album => {
                    return <li>{album.title}</li>
                })}
            </ul>
        </Suspense>
    </div>
}
....................................................................................
			How to externalize the data
.....................................................................................

In the above example we have hardcoded the full url

const url = `http://localhost:3000/api/albums`

How to externalize the config data....

We have file called ".env" file
....................................................................................
			  Environment Variables
....................................................................................

Next js comes with built in support for environment variables, which allows you make to your app more flexible.

.env file syntax

.env.environment

.environment is "dev | prod | test"

.env.development
.env.production
.env.test
.env.local

eg:
rest-app -->Project root dir
 |
.env.local
 API_HOST=localhost
 API_PORT=3000
 HOST=http://$API_HOST:$PORT 


How to load env variables?
async function getAlbums() {
    // const url = `http://localhost:3000/api/albums`
    const url = `${process.env.HOST}/api/albums`

    const res = await fetch(url)
    if (!res.ok) {
        throw new Error('data is not available')
    }
    return res.json()
}
.....................................................................................
			 How to read Request payload
.....................................................................................

request.json method is used to extract body which sent by the client

export  async function POST(request) {
    const customer = await request.json()
    console.log(customer)
    //send response
    return NextResponse.json({ message: 'CUSTOMERS POST' })
}

How to post data to the rest api(third party)?

.env.local
JSON_PLACEHOLDER=https://jsonplaceholder.typicode.com

src/app/api/alubum/route.js
import { NextResponse } from "next/server";

const url = `${process.env.JSON_PLACEHOLDER}/albums`

//rest api
export async function GET(request) {
    //use fetch api to talk to rest end points
    const res = await fetch(url)
    const albums = await res.json();
    //send response
    return NextResponse.json(albums)
}
export async function POST(request) {
    const album = await request.json()
    //post data to json place holder api
    const res = await fetch(url, {
        method: 'POST', headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(album)
    })
    //send response
    const newAlbum = await res.json();
    return NextResponse.json(newAlbum)
}

import { NextResponse } from "next/server";

const url = `${process.env.JSON_PLACEHOLDER}/albums`

//rest api
export async function GET(request) {
    //use fetch api to talk to rest end points
    const res = await fetch(url)
    const albums = await res.json();
    //send response
    return NextResponse.json(albums)
}
export async function POST(request) {
    const album = await request.json()
    //post data to json place holder api
    const res = await fetch(url, {
        method: 'POST', headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(album)
    })
    //send response
    const newAlbum = await res.json();
    return NextResponse.json(newAlbum)
}

export async function PUT(request) {
    const { id, userId, title } = await request.json()
    console.log(id,userId,title)
    //console.log(ablumn)
    //post data to json place holder api
    const res = await fetch(`${url}/${id}`, {
        method: 'PUT', headers: {
            'Content-Type': 'application/json'
            , body: {
                id, userId, title
            }
        }
    })
    //send response
    const updatedAlbum = await res.json()
    return NextResponse.json(updatedAlbum)
}

In order to work delete operation , we need to down grade
 "dependencies": {
    "next": "13.2.4",
    "react": "18.2.0",
    "react-dom": "18.2.0"
  }
}
next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
    experimental: {
        appDir: true,
    },
}

module.exports = nextConfig


				GraphQL
.....................................................................................

What is GraphQL?
	GraphQL is a "new API" standard that provides a more efficient, powerful and flexible alternative to REST.

API:
 Appliation programming interface : Entry and exit point for data access.

How apis are represented /encapsulated?
 inside objects

Types of apis:
 1.local api
	api which is part of single runtime- jvm
 2.remote api
       rpc
	 -webservices -  rest api,soap api
         -rpi - grpc
         -tcp based apps
         -smtp based app
       etc...

REST:
   REST has not been designed to be user centric rather than data centric...

if you define any api, which returns data set eg: if you query an api called products

products may have so many fields, i dont want all fields which exposed by the api...

GET  /api/products

 =>[{
  ...
 }]

At its core, GraphQL enables declarative data fetching where a client can specify exactly what data it needs from an API.

Instead of multiple endpoints that return fixed data structures, a GraphQL server only exposes a single endpoint and responds with precisely the data a client asked for.

GraphQL - A Query Language for APIs
Most applications today have the need to fetch data from a server where that data is stored in a database. Itâ€™s the responsibility of the API to provide an interface to the stored data that fits an applicationâ€™s needs.

GraphQL is often confused with being a database technology. This is a misconception, GraphQL is a query language for APIs - not databases. In that sense itâ€™s database agnostic and effectively can be used in any context where an API is used.


A more efficient Alternative to REST
....................................

REST has been a popular way to expose data from a server. When the concept of REST was developed, client applications were relatively simple and the development pace wasnâ€™t nearly where it is today. REST thus was a good fit for many applications. However, the API landscape has radically changed over the last couple of years. In particular, there are three factors that have been challenging the way APIs are designed:

1. Increased mobile usage creates need for efficient data loading
Increased mobile usage, low-powered devices and sloppy networks were the initial reasons why Facebook developed GraphQL. GraphQL minimizes the amount of data that needs to be transferred over the network and thus majorly improves applications operating under these conditions.

2. Variety of different frontend frameworks and platforms
The heterogeneous landscape of frontend frameworks and platforms that run client applications makes it difficult to build and maintain one API that would fit the requirements of all. With GraphQL, each client can access precisely the data it needs.

3. Fast development & expectation for rapid feature development
Continuous deployment has become a standard for many companies, rapid iterations and frequent product updates are indispensable. With REST APIs, the way data is exposed by the server often needs to be modified to account for specific requirements and design changes on the client-side. This hinders fast development practices and product iterations.
.....................................................................................
			  How to begin with GraphQL


GraphQL is platform and language independant.

GraphQL Can be classified into two category

1.Client side - How to send data(Request) to the GraphQL server.
  in order to send data from the client face book published one spec

called
   "GraphQL Query language spec"

2.Server side - How to build graph(object tree) from the data sources
    "GraphQL Schema language spec"

.....................................................................................
			  GraphQL request and response model.


Declarative Programming:

What you write, you have to get the same structure.

The Query request is more readable,declarative. WHich micics the javascript object literal syntax.

js object:

 let user =  {
     id:1,
     name:'joe'
     friends: [
        'bar','foo'
     ]
  } 

GraphQL Request payload : GraphQL Query
.......................................

GraphQL Client 

POST /endpoint

  {
     id
     name
     friends { -----------------------------> GraphQLServer
        name
     }
  } 

Response:JSON
 {
     "id":1,
     "name":"joe"
     "friends": [      <----------------------------- GraphQLServer
        "bar","foo"
     ]
  } 

..............................................................................................
				 REST AND CURD

Operations Type

GET ------Read
POST -----CREATE
PUT ------UPDATE
DELETE----Remove
.............................................................................................
				GRAPHQL And CURD


GraphQL uses only URL which exposes Service


  {
     id
     name
     friends { -----------HTTP POST------------------> GraphQLServer
        name
     }
  } 

Operation Types:

1.Query === GET request in HTTP server
  read
2.mutation === HTTP POST,PUT,DELETE
  create,update,delete
3.subscription
   Streaming

query - a read only fetch
mutation- a write followed by read
subscription- a long live request that fetches data in response to source events
..................................................................................
			 Graphql Query language - Spec
.....................................................................................

Client Side development:
 In this module, we are going to learn how to send request(graphql) request to graphql server..

Syntax:

1.Selection set

selectionSet: {
 Selection
}

Selection:
 fields
 Fragment Spread
 inline fragament

SelectionSet : What type of operations (query,mutation,subscription)

Read:

query  {
    fields
    Fragment Spread
   inline fragament
}
fields: could be what are the data you are expecting from the server
eg:User information 
in the server user information could be many fields
 firstName,lastName,id,age,city,state,status,pic,stars,ranking....

field List :
 You are asking the server that , hey i want only these fields

query  {
   id
   firstName  ====>POST request=========/url===>GraphQLServer==>Execute api
   lastName   <====response would be json
}

Create,Update,Remove: Mutation

mutation createUser(params) { 
  user
}
mutation updateUser(params) { 
  user
}
mutation removeUser(params) { 
  user
}

Streaming: (read with Streaming)

subscription  getStockQuote (params){
  name
  price
  qty
}
.....................................................................................
			  How to learn graphql query language

in order to work with query language we need graphql server, if you dont have local graphql server we can use mock apis

Fake api servers
https://graphqlzero.almansi.me/#example-top
https://countries.trevorblades.com/
 
Tools to test graphql end points

1.Client tools
 playground
 postman

Core concepts:
=>fields
=>arguments
=>aliases
=>fragments
=>variables
=>directives
=>Mutations
=>inline fragments

Fiedls:
  At its simplest, GraphQL is about asking for specific fields on objects.

Lets start by looking at a very simple query and the result we get when we run it.

Simple Query:

query {
  countries {
    code
    name
  }
}
Sample response:
  "data": {
    "countries": [
      {
        "code": "AD",
        "name": "Andorra"
      },
      {
        "code": "AE",
        "name": "United Arab Emirates"
      },
      {
        "code": "AF",
        "name": "Afghanistan"
      },
      {
        "code": "AG",
        "name": "Antigua and Barbuda"
      },
      {
        "code": "AI",
        "name": "Anguilla"
      },
      {
        "code": "AL",
        "name": "Albania"
      },
      {
        "code": "AM",
        "name": "Armenia"
      },
      {
        "code": "AO",
        "name": "Angola"
      },
      {
        "code": "AQ",
        "name": "Antarctica"
      },
      {
        "code": "AR",
        "name": "Argentina"
      },
      {
        "code": "AS",
        "name": "American Samoa"
      }
]

Short cut:
 we dont need to specificy query keyword
{
  countries {
    code
    name
  }
}
More fields:
 How do we know that the api has more fields?
In the playground, we can see docs in the playground

 {
    countries {
        name
        code
        native
        capital
        currency
    }
}

Inside Graphql server, the above fields are encapulated inside object.
Object property may nest other objects.

How to query nested values?

 {
    countries {
        name
        code
        native
        capital
        currency
        continent {
            name
        }
    }
}

We can use method name syntax
 query getAllCountries {
    countries {
        name
        code
        native
        capital
        currency
        continent {
            name
        }
    }
}
We will see where method syntax is useful.
.....................................................................................
			   Arguments
.....................................................................................

What if i want to get data based  on some condition or conditions?

Synax:

 query getCountryByCode {
     country(code:"US"){
          name
          capital
          currency
          phone
     }
     continent(code:"AS") {
         name
     }
}
Here code is variable , "US" is value

Arg can be static or dynamic arg

Static means passing hardcoded value..

 query getCountryByCode {
     country(code:"US"){
          name
          capital
          currency
          phone
     }
     continent(code:"AS") {
         name
     }
}
...................................................................................
			 Dynamic parameters and arguments -Variables
...................................................................................

Variables:
 Variables are place holders to have dynamic values.
 In case of clients app,you may select values from the drop down or from text field

Variables are introduced in graphql via "$VariableName"

Steps: 
1.replace static values in the query with $variable
2.Declare the variable ($VariableName) as part of the query header

Static
 query getCountryByCode {
     country(code:"US"){
          name
          capital
          currency
          phone
     }
     
}
Dynamic
 query getCountryByCode($variableName:DataType) {
     country(code:$variableName){
          name
          capital
          currency
          phone
     }
     
}
 query getCountryByCode($code:ID!) {
     country(code:$code){
          name
          capital
          currency
          phone
     }
     
}
How to pass values to this Query?
 Via Query variables in playground.

{
    "code":"IN"
}

Response:
{
    "data": {
        "country": {
            "name": "India",
            "capital": "New Delhi",
            "currency": "INR",
            "phone": "91"
        }
    }
}
...................................................................................
			Default Arg
....................................................................................

What if i dont send the query variable as input, we can substitue default value

 query getCountryByCode($code:ID!="IN") {
     country(code:$code){
          name
          capital
          currency
          phone
     }
     
}

if you pass  country code, you will get response
{
    "code":"US"
}
Response:

{
    "data": {
        "country": {
            "name": "United States",
            "capital": "Washington D.C.",
            "currency": "USD,USN,USS",
            "phone": "1"
        }
    }
}
if you dont pass country code
{
    "data": {
        "country": {
            "name": "India",
            "capital": "New Delhi",
            "currency": "INR",
            "phone": "91"
        }
    }
}
....................................................................................
			Short cut :without method Name 
 query ($code:ID!="IN") {
     country(code:$code){
          name
          capital
          currency
          phone
     }
     
}
Recommendation : having method name for more readablity.

 query getCountryByCode($code:ID!="IN") {
     country(code:$code){
          name
          capital
          currency
          phone
     }
     
}
What can be parameter or arg types?

1.Can be primitives(Scalar types) - ID,String,Int,Float,Enums
2.Can be complex types - Object Types

Input type:
 Input is special complex type, used to represent input parameters.
 Input types are very usefull incase of mutation

I want to get Language information.

query getlanguageInfo($filter:LanguageFilterInput) {
    languages(filter:$filter) {
        code 
        name
        native
        rtl
    }
}

After execution , you will get all language info

{
    "data": {
        "languages": [
            {
                "code": "af",
                "name": "Afrikaans",
                "native": "Afrikaans",
                "rtl": false
            },
            {
                "code": "am",
                "name": "Amharic",
                "native": "áŠ áˆ›áˆ­áŠ›",
                "rtl": false
            },
            {
                "code": "ar",
                "name": "Arabic",
                "native": "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©",
                "rtl": true
            },
            {
                "code": "ay",
                "name": "Aymara",
                "native": "Aymar",
                "rtl": false
            },
            {
                "code": "az",
                "name": "Azerbaijani",
                "native": "AzÉ™rbaycanca / Ø¢Ø°Ø±Ø¨Ø§ÙŠØ¬Ø§Ù†",
                "rtl": false
            },
            {
                "code": "be",
                "name": "Belarusian",
                "native": "Ð‘ÐµÐ»Ð°Ñ€ÑƒÑÐºÐ°Ñ",
                "rtl": false
            },
            {
                "code": "bg",
                "name": "Bulgarian",
                "native": "Ð‘ÑŠÐ»Ð³Ð°Ñ€ÑÐºÐ¸",
                "rtl": false
            }
]

After giving query variable:

{
    "filter": {
        "code" : {
            "eq" : "en"
        }
    }
}

Response :
{
    "data": {
        "languages": [
            {
                "code": "en",
                "name": "English",
                "native": "English",
                "rtl": false
            }
        ]
    }
}
...................................................................................
			Multiple arg variables
...................................................................................

Multiple Variables:
....................

query getProfile($id:Int,$withFriends:Boolean=false) {

     user(id:$id,withFriends:$withFriends) {
	  name
          pic
      }
}
Passing values:
{"id":1 , "withFriends" : true}
{"id":2 }
.....................................................................................	
                       Alises
....................................................................................

Filed Alises gives dummy name for keys..

Syntax:
 without Aliases:

query { 
  user(id:1){
    id 
    name
  }
}
Response:
{
  "data": { 
    "user": {
	"id":1
         "name":"Subramanian"
    }
  }
}

With Alises:

query { 
  subramanian:user(id:1){
    id 
    name
  }
}
Response:
{
  "data": { 
    "subramanian": {
	"id":1
         "name":"Subramanian"
    }
  }
}
eg:
query getlanguageInfo($filter:LanguageFilterInput) {
    englishLanguage:languages(filter:$filter) {
        code 
        name
        native
        rtl
    }
}
{
    "data": {
        "englishLanguage": [
            {
                "code": "en",
                "name": "English",
                "native": "English",
                "rtl": false
            }
        ]
    }
}
.....................................................................................
			Fragements : Resuable Selection Set
.....................................................................................

Without fragement:
...................

query {
   user(id:2){
      friends {
	id 
        name
        pic
      }
      mutualfriends {
	id 
        name
        pic
      }
   }
}
Here friends and mutual friends are having same set of data
...................................................................................
With Fragements:
...............
query {
   user(id:2){
      friends {
	...friendsFields
      }
      mutualfriends {
	...friendsFields
      }
   }
}

fragement friendsFields on User{
        id 
        name
        pic
}

eg:
query GetA1AndA2Countries {
    a1Countries:countries {
        ...countryInfo
    }
    a2Countries:countries {
        ...countryInfo
    }
}
fragment countryInfo on Country {
    name
    capital
}

Response:
"data": {
        "a1Countries": [
            {
                "name": "Andorra",
                "capital": "Andorra la Vella",
                "__typename": "Country"
            },
            {
                "name": "United Arab Emirates",
                "capital": "Abu Dhabi",
                "__typename": "Country"
            },
            {
                "name": "Afghanistan",
                "capital": "Kabul",
                "__typename": "Country"
            }
	 ],
	 "a2Countries": [
            {
                "name": "Andorra",
                "capital": "Andorra la Vella",
                "__typename": "Country"
            },
            {
                "name": "United Arab Emirates",
                "capital": "Abu Dhabi",
                "__typename": "Country"
            },
            {
                "name": "Afghanistan",
                "capital": "Kabul",
                "__typename": "Country"
            }
	 ]
}
.....................................................................................				   Directives
....................................................................................
Directives are built in functions which provides some utilites.
Directives starts with @DirectiveName(arg:Type)

Built in directives
@include(if:Boolean)
  conditionally include this field in the result if the arg is true
@skip(if:Boolean)
   conditionally exclude this field in the result if the arg is true

Syntax:
query getProfile($id:Int,$withFriends:Boolean=false){ 
	
     user(id:$id) {
	name
	pic
	friends @include(if:$withFriends){
		name
	}
     }  
      

}

Query Variable:
 {"id":5, "withFriends":true}

eg:
query getLanguage($code:ID!,$rtl:Boolean!) {
    language(code:$code){
        name 
        native @include(if:$rtl)
    }
}

Query Variable:
{
    "code":"en",
    "rtl":true
}

Response:
{
    "data": {
        "language": {
            "name": "English",
            "native": "English"
        }
    }
}			

False condition:
Query Variable:
{
    "code":"en",
    "rtl":false
}		
Response:
{
    "data": {
        "language": {
            "name": "English"
        }
    }
}
....................................................................................
				Mutations
...................................................................................

How to send payload to create,update,delete
IN REST

POST=>CREATE
PUT=>UPDATE
DELETE=>REMOVE
GET=>READ

Mutations 
........

mutation is keyword used to create,update,remove...

API url :
https://graphqlzero.almansi.me/api

CREATE:
.......
eg:
mutation CreatePost(
  $input: CreatePostInput!
) {
  createPost(input: $input) {
    id
    title
    body
  }
}

Query Variables:
{
  "input": {
    "title": "A Very Captivating Post Title",
    "body": "Some interesting content."
  }
}

Response:

{
    "data": {
        "createPost": {
            "id": "101",
            "title": "A Very Captivating Post Title",
            "body": "Some interesting content."
        }
    }
}
........................

Update :
mutation UpdatePost($id: ID!,$input: UpdatePostInput!) {
  updatePost(id: $id, input: $input) {
    id
    body
  }
}
Query Variable

{
  "id": 1,
  "input": {
    "body": "Some updated content."
  }
}

Response
{
  "updatePost": {
    "id": "1",
    "body": "Some updated content."
  }
}
....................................................................................
Delete :

mutation RemovePost($id: ID!) {
  deletePost(id: $id)
}
Query Variable:

{
  "id": 101
}.
Response:
{
  "deletePost": true
}
...................................................................................
			 Server side : GraphQL schema Language
....................................................................................

How to build rest api?
  According to rest spec,The problems(domain) are represented as "resources"

Resource represents a Object which expose data and api.
eg:CustomerResource,OrderResource,ProductResource.

Resources are identified by URL 
eg:/
	/api/products and Methods are "GET/POST/PUT/DELETE"

How to build graphql applications?
 According to graphql specifications problems are represented as "Schema"
Schema represents domain models.
Domain Models are represetented as Objects | models | entity.

eg:
 Customer,Order,Product.

In Programming side schema is represented as "Objects and its relationship"
Object and its relationship forms "graph" - Object Graph
.....................................................................................
How to start write graphql apps?
   
   In order to begin with, we need learn there is language called "SDL" - Schema definition language.

SDL Core concepts:
.................

1.Type system.
 The type system defines the Platform independent data types and variables which describe what data can be quired by client.


Flow of client and server

query getUserData {
   user {
     name ===>SDL============>Server==>SDL===Entity==>Biz logic(Services)===>Data 									sources
  }
}

Both client and server talks via common language called "SDL" language

SDL provides language independent abstraction.

	     SDL-----|JAVA/js/python/c++ ...
...................................................................................	
			How to write schema
....................................................................................

The schema file is saved as "fileName.schema".

Schema is collection of Object types that contain fields.Each field has a type of its own.
A field type can be scalar(primitives Such as Int,String) or it can another object type.eg User can have Address type.

We need to with key word called "type"

type TypeName {
  field:Datatype
}

In SDL, there is root type, every type is dervied from the root type only.

Root Type:

type schema{
  query:Query
  mutation:Mutation
  subscription:Subscription
}
Query Type: contains read api
type Query{
 #api
 greet:String
 name:String
}
type Mutation {
 #api
 save(param:String):String
}
type Subscription {
 #api
 getStockQuote:String
}
....................................................................................
SDL Defines its language and platform independant data types

1.scallar types
2.Custom types/Reference Types/Object types.

1.Scallar types
 Scallares are primitive types in your language.

1.Int -32 bit signed integer
2.String-UTF-8 char sequence
3.Boolean - true or false
4.Float - signed Double
5.ID(Serialized String) - A unique identifier.

2.Custom types
 Similar to classes in Object oriented languages like c++ ,java,C#,Typescript

type User{
  id:ID
  firstName:String
  lastName:String
  age:Int
  points:Float
  status:Boolean
}

Object can have other objects : Nested Object
  HAS-A relationship or Depedency Injection


type Address {
  city:String
  state:String
  zipCode:String
}

type User{
  id:ID
  firstName:String
  lastName:String
  age:Int
  points:Float
  status:Boolean
  address:Address
}
...................................................................................
			Handling null and not null
..................................................................................

Client Query with data

{
  name =====> response {name:'Subramanian'}
}


Client Query without data

{
  name =====> response {name:null}
}
null values some times create issues in the client applications, what if i want to return always value without null.

I dont want null value for a given field? How to force the field must have data or must not have null?

=>Not null fields

Syntax:
  fieldName:Type!
! =>Not null

type Address {
  city:String!
  state:String
  zipCode:String
}

type User{
  id:ID!
  firstName:String!
  lastName:String!
  age:Int
  points:Float
  status:Boolean
  address:Address
}
....................................................................................
			Collection - List of similar Values
..................................................................................

A field may have one or more values

fieldName:[DataType]
 Here Datatype can be scalar type or Object type

fieldName:[String] | [Int] | [Float]
fieldName:[Address] [Order] [Items]

Collection can also be not null

fieldName:[String]! | [Int]! | [Float]!
fieldName:[Address]! [Order]! [Items]!
.....................................................................................
			Query Type
.....................................................................................

Query is collection of apis
Query api can accept input and return values

No parameter: only Return
..........................
field:Type

eg:

type Query {
  name:String
  user:User
  users:[User]
}
Client side:Query language 
{
  name
}
{
  user {
   id
   name
  }
}
{
  users {
     user { 
	id 
	 name
     }
  }
}
Parameters, And Return value:
.............................
field:Type

type Query {
   name(name:String,message:String):String
   userById(id:ID):User
   usersByCity(city:String):[User]!
}
.....................................................................................
			 Advanced Types
.....................................................................................

=>Mutation
=>Subscription
=>Input
=>Enum
=>Union
=>Interface

Mutation:
 Write and Read operations where as Query type is read only.

Signature of the Mutation:

type Mutation{
  createUser(id:ID,name:String,lastName:String,age:Int):User
  updateUser(id:ID,user:User):User
  removeUser(id:ID):User
}

in the above example, more no parameters we need to pass, which makes your code more difficult to understand and read thats where we have new type called "INPUT" type.
...................................................................................
			  Input Types
.................................................................................

Input types are special object types that allow you to provide hierachical data as arguments to fields(as apposed to providing only flat scalar args).
type Mutation{
 #Flat scalar args
  createUser(id:ID,name:String,lastName:String,age:Int):User
}

type Address {
  city:String!
  state:String
  zipCode:String
}

type User{
  id:ID!
  firstName:String!
  lastName:String!
  age:Int
  points:Float
  status:Boolean
  address:Address
}

input CreateUserInput{
  id:ID!
  name:String
  lastName:String
  age:Int
}
input CreateUserResponse{
  id:ID!
  name:String
  lastName:String
  age:Int
}

type Mutation{
  createUser(userInput:CreateUserInput!):CreateUserResponse
}
...................................................................................
			   Enums
....................................................................................
An Enum is similar to scalar types, but its legal values are defined in the schema

enum Gender {
  MALE
  FEMALE
  THIRD
}
How to use Enum


type User{
  id:ID!
  firstName:String!
  lastName:String!
  gender:Gender
  age:Int
  points:Float
  status:Boolean
  address:Address
}
.....................................................................................
			  Union and Interfaces
....................................................................................
Union:
  Unions and interfaces abstract graphql types that enables a schema field to return one of multiple object types.

union Media = Image | Video

type Query {
  getMedia:Media
}

Union type must not be scallar type values it must be always object

 union Foo: String | Int => which is wrong
.....................................................................................
                        Interfaces
.....................................................................................

interface represents common fields that multiple objects can include.

interface Book{ 
  title:String!
  author:String!
}

type TechnicalBook implments Book { 
  title:String!
  author:String!
  X:String
}


type StoryBook implments Book { 
  title:String!
  author:String!
  Y:String
}
....................................................................................
			  Custom Scallar

Graphql SDL provides basic core types - Int,String,Boolean,ID,Float
What if i want other types like Date,Time

How to define custom scalar?

scalar Date

type User{
  id:ID!
  firstName:String!
  lastName:String!
  gender:Gender
  dob:Date
  age:Int
  points:Float
  status:Boolean
  address:Address
}
Date if you declare , you wont get date value, rather we need to write logic how date is represented in server side.
....................................................................................
			 Custom Directives
....................................................................................
directive @cacheControl(
  maxAge: Int
  scope: CacheControlScope
) on FIELD_DEFINITION | OBJECT | INTERFACE

Here we create @cacheControl directives, we need to write logic in the server side code..
....................................................................................
			GRAPHQL Application dev
.....................................................................................

Requirement:
 1.You must have SDL before starting any code

Graphql application can be written in any language..

Javascript implmentation (runtime is Node.js)

1.graphql.js
  =>Core framework written by facebook 
  =>You can run standalone or on top of  web servers
  =>Express.js is underlying framework
2.Apollo
   =>It is platform for building graphl apps called "SuperGraphs"
   =>It is written on the top of express server with microservice developments.

Components of Apollo(Graphql apps):

1.Apollo Server
2.Schema definitions - SDL
3.Resolvers - Schema Implmenetation - where we write biz logic
4.Datasources- Database or another rest api...
.....................................................................................
Apollo Project setup:
.....................
Apollo project can be started with typescript or plain javacript: Typescript is mostly recommended..

E:\session\IBM\2023\May\NextJS\>mkdir apollo-gettingstarted
E:\session\IBM\2023\May\NextJS>cd apollo-gettingstarted
E:\session\IBM\2023\May\NextJS\apollo-gettingstarted> npm init --yes
E:\session\IBM\2023\May\NextJS\apollo-gettingstarted> code .
E:\session\IBM\2023\May\NextJS\apollo-gettingstarted> mkdir src

Install depedencies:

npm i @apollo/server graphql

Typescript dependency:

npm i --save-dev typescript @types/node

create tsconfig.json
{
    "compilerOptions": {
        "rootDirs": ["src"],
        "outDir": "dist",
        "lib":["es2020"],
        "target": "ES2020",
        "module": "ESNext",
        "moduleResolution": "node",
        "esModuleInterop": true,
        "types": ["node"]
    }
}

script configuration:

 "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "compile": "tsc",
    "start": "npm run compile && node ./dist/index.js"
  },

write code inside src/index.ts
console.log('welcome to Apollo Server')
....................................................................................

Steps:

1.Define Schema
2.Write Biz logic based on Schema - Resolvers
3.Start Apollo Server
4.Query data from the client.


Define Schema:
 Schema definition is represented as "Plain String"

Steps:
1.src/index.ts

//Define schema
const typeDefs=`
#Simple Query which returns Hello World
 type Query {
    hello:String    
 }
`
2.Biz logic : write biz logic for Query: resolover 
//Define Resolver: biz logic
const resolvers = {
    //Query Implmentation
    Query: {
        hello() {
            return "Hello World"
        }
    }
    //Mutation
    
    //Subscription
}

3.We need to deploy(Parse schema,bind resolvers)

3.1. import ApolloServer  and create instance

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

3.2.Start web Container and deploy
const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)

How to test?
http://localhost:4000/ 

You can see there is playground provided by Apollo server by default

query {
  hello
}

Response:
{
  "data": {
    "hello": "Hello World"
  }
}
....................................................................................
			Multiple Apis
....................................................................................
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//Define schema
const typeDefs = `
#Simple Query which returns Hello World
 type Query {
    hello:String
    greet:String
    hai:String    
 }
`
//Define Resolver: biz logic
const resolvers = {
    //Query Implmentation
    Query: {
        hello() {
            return "Hello World"
        },
        hai() {
            return 'Hai GraphQL'
        },
        greet() {
            return 'Greet GraphQL'
        }

    }
    //Mutation

    //Subscription
}

//create instance of ApolloServer and pass schema , resolver as config

const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)
.....................................................................................
			Object Types and Queries
....................................................................................	import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//Define schema
const typeDefs = `
#Simple Query which returns Hello World
 
 type User {
    id:ID
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
 }

 type Query {
   user:User
 }
`
//Define Resolver: biz logic
const resolvers = {
    //Query Implmentation
    Query: {
        user() {
            //return object
            return {
                id: 1,
                firstName: 'Subramanian',
                lastName: 'Murugan',
                age: 10,
                points: 10.5,
                status: true

            }
        }
    }
    //Mutation

    //Subscription
}

//create instance of ApolloServer and pass schema , resolver as config

const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)

Testing:
query {
  user {
    id
    firstName
    status
  }
}
{
  "data": {
    "user": {
      "id": "1",
      "firstName": "Subramanian",
      "status": true
    }
  }
}
.................................................................................
			Collections
................................................................................	
src/mock-data/users.ts
export const USERS: Array<any> = [{
    id: 1,
    firstName: 'Subramanian',
    lastName: 'Murugan',
    age: 10,
    points: 10.5,
    status: true

},
{
    id: 2,
    firstName: 'Geetha',
    lastName: 'Subramanian',
    age: 34,
    points: 10.5,
    status: true

},
{
    id: 3,
    firstName: 'Murugan',
    lastName: 'Palanisamy',
    age: 58,
    points: 10.5,
    status: true

}
]

	
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'
import { USERS } from "./mock-data/users.js"

//Define schema
const typeDefs = `
#Simple Query which returns Hello World
 
 type User {
    id:ID
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
 }

 type Query {
   user:[User]
 }
`
//Define Resolver: biz logic
const resolvers = {
    //Query Implmentation
    Query: {
        user() {
            //return object
            return USERS
        }
    }
    //Mutation

    //Subscription
}

//create instance of ApolloServer and pass schema , resolver as config

const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)
....................................................................................
			 Handling Args and Parameters
...................................................................................
How to handle args/parameters?
 A Resolver function takes four positional args

fun(parent,args,contextValue,info){


}
args it is variable going to hold parameters passed by clients.
args value is going to be literal object
How many parameters if you pass, all parameters are stored inside single literal object
import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'
import { USERS } from "./mock-data/users.js"

//Define schema
const typeDefs = `
#Simple Query which returns Hello World
 type Query {
     hello(name:String):String
 }
`
//Define Resolver: biz logic
const resolvers = {
    //Query Implmentation
    Query: {
        hello(parent, args, contextValue, info) {
            console.log(args)
            const { name } = args
            // return `Hello ${args.name}`
            return `Hello ${name}`
        }
    }
    //Mutation

    //Subscription
}

//create instance of ApolloServer and pass schema , resolver as config

const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)

Testing:
Dynamic variables
query SayHello($name: String) {
  hello(name: $name)
}
Query Variable
{
  "name": "Subramanian"
}
{
  "data": {
    "hello": "Hello Subramanian"
  }
}
....................................................................................
			Handling Complex Args and Parameters


import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'
import { USERS } from "./mock-data/users.js"

//Define schema
const typeDefs = `
#Simple Query which returns Hello World
 
 type User {
    id:ID
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
 }
 input UserResponseInput {
    id:ID
    firstName:String
    lastName:String
    age:Int
    points:Float
    status:Boolean
 }
 type Query {
   users:[User]
   userById(id:ID!):User
 }
`
//Define Resolver: biz logic
const resolvers = {
    //Query Implmentation
    Query: {
        users() {
            //return object
            return USERS
        },
        //here _ is just convention to skip the arg
        userById(_, args) {
            const { id } = args
            //filter data based on id
            return USERS.find(user => {
                return user.id === +id
            })
        }
    }
    //Mutation

    //Subscription
}

//create instance of ApolloServer and pass schema , resolver as config

const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)

Query:
query Users($userByIdId: ID!) {
  userById(id: $userByIdId) {
    id
    firstName
    lastName
  }
}

QueryVariable:
{
  "userByIdId": 2
}
Response:
{
  "data": {
    "userById": {
      "id": "2",
      "firstName": "Geetha",
      "lastName": "Subramanian"
    }
  }
}

if parameter does not match , it will return null value...
.....................................................................................
			Nested Data Structure
.....................................................................................

I have data Structure

const users = [
  { 
   id:1,
   name:'A',
   email:'a@gmail.com'
   address: {
    city:'b',
    state:'c'
   }
  }
]

Schema:
//Define schema
const typeDefs = `

type User {
   id:ID!
   name:String
   email:String
   address:Address
}
type Address{
    city:String
    state:String
}
type Query {
    users:[User]
}

In database world user and Address would have stored into different tables.
CREATE Table users(id int,name varchar(10),email varchar(20,constraint c primaryKey(id))

CREATE Table address(city varchar(20),state varchar(20),id references users id)
...................................................................................
Mock data:

//Mock data
const USERS = [{
    id: 1,
    name: 'A',
    email: 'a@gmail.com'
},
{
    id: 2,
    name: 'B',
    email: 'b@gmail.com'
},
{
    id: 3,
    name: 'C',
    email: 'c@gmail.com'
}

]

const ADDRESS = [{
    city: 'Coimbatore',
    state: 'TN',
    id: 1 //linking field
},
{
    city: 'BNG',
    state: 'KA',
    id: 2 //linking field
},
{
    city: 'HYD',
    state: 'TS',
    id: 3 //linking field
}]

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//Mock data
const USERS = [{
    id: 1,
    name: 'A',
    email: 'a@gmail.com'
},
{
    id: 2,
    name: 'B',
    email: 'b@gmail.com'
},
{
    id: 3,
    name: 'C',
    email: 'c@gmail.com'
}

]

const ADDRESS = [{
    city: 'Coimbatore',
    state: 'TN',
    id: 1 //linking field
},
{
    city: 'BNG',
    state: 'KA',
    id: 2 //linking field
},
{
    city: 'HYD',
    state: 'TS',
    id: 3 //linking field
}]

//Define schema
const typeDefs = `

type User {
   id:ID!
   name:String
   email:String
   address:Address
}
type Address{
    city:String
    state:String
}
type Query {
    users:[User]
}
`
//Define Resolver: biz logic
const resolvers = {
    //Query Implmentation
    Query: {
        users() {
            //return object
            return USERS
        },
    }
    //Mutation

    //Subscription
}

//create instance of ApolloServer and pass schema , resolver as config

const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)

Testing:
query Users {
  users {
    id
    name
    email
    address {
      city
    }
  }
}

Response:
{
  "data": {
    "users": [
      {
        "id": "1",
        "name": "A",
        "email": "a@gmail.com",
        "address": null
      },
      {
        "id": "2",
        "name": "B",
        "email": "b@gmail.com",
        "address": null
      },
      {
        "id": "3",
        "name": "C",
        "email": "c@gmail.com",
        "address": null
      }
    ]
  }
}
Here address is missing, that means address is only part of schema but not part of the resolver

How to link users with Address?
...................................................................................
			  Resolver Chains
..................................................................................
Resolver chain means coimbing results of one resolve with in nested resolver

import { ApolloServer } from "@apollo/server"
import { startStandaloneServer } from '@apollo/server/standalone'

//Mock data
const USERS = [{
    id: 1,
    name: 'A',
    email: 'a@gmail.com'
},
{
    id: 2,
    name: 'B',
    email: 'b@gmail.com'
},
{
    id: 3,
    name: 'C',
    email: 'c@gmail.com'
}

]

const ADDRESS = [{
    city: 'Coimbatore',
    state: 'TN',
    id: 1 //linking field
},
{
    city: 'BNG',
    state: 'KA',
    id: 2 //linking field
},
{
    city: 'HYD',
    state: 'TS',
    id: 3 //linking field
}]

//Define schema
const typeDefs = `

type User {
   id:ID!
   name:String
   email:String
   address:Address
}
type Address{
    city:String
    state:String
}
type Query {
    users:[User]
}
`
//Define Resolver: biz logic
const resolvers = {
    //Query Implmentation
    Query: {
        users() {
            //return object
            return USERS
        },
    },
    //Resolver Chain
    User: {
        address(parent, args, contextValue, info) {
            console.log(parent)
            //connect parent with child: connect this address with user 
            return ADDRESS.find(address => {
                //linking field === parent field
                return address.id === parent.id
            })
        }
    }
    //Mutation

    //Subscription
}

//create instance of ApolloServer and pass schema , resolver as config

const server = new ApolloServer({
    typeDefs: typeDefs,
    resolvers: resolvers
})

const { url } = await startStandaloneServer(server, {
    listen: {
        port: 4000
    }
})
console.log(`Apollo Server is Ready at ${url}`)

Testing:
query Users {
  users {
    id
    name
    email
    address {
      city
    }
  }
}

Response:
{
  "data": {
    "users": [
      {
        "id": "1",
        "name": "A",
        "email": "a@gmail.com",
        "address": {
          "city": "Coimbatore"
        }
      },
      {
        "id": "2",
        "name": "B",
        "email": "b@gmail.com",
        "address": {
          "city": "BNG"
        }
      },
      {
        "id": "3",
        "name": "C",
        "email": "c@gmail.com",
        "address": {
          "city": "HYD"
        }
      }
    ]
  }
}



